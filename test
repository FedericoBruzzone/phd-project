The rapid evolution of software development necessitates efficient tools for creating and integrat-
ing programming languages. Integrated Development Environments (IDEs) and source-code editors
(SCEs) offer vital support features like syntax highlighting, code completion, and debugging, but
their development is often complex and labor-intensive. Language Server Protocol (LSP) and
Debugger Adapter Protocol (DAP) were introduced to simplify this process by providing a
standardized API, decoupling language support implementation from specific editors. Despite these
advancements, the integration of LSP and DAP remains challenging due to fragmented and inconsis-
tent approaches. Modern language workbenches have made strides in modularization, composition,
and IDE integration. However, their methods for LSP and DAP generation often lack a standard-
ized and cohesive framework, resulting in increased complexity and reduced efficiency. By leveraging
techniques like feature-oriented programming and software product lines (SPLs), there is potential
to enhance modularity and reusability in language server development. This approach promotes a
bottom-up methodology where LSP and DAP functionalities are encapsulated in feature modules,
enabling a more compositional and efficient implementation process. Nowadays, Xtext [6] is one
of the few language workbenches that support LSP generation [2]. Neverlang, developed at the
ADAPT-Lab of the Università degli Studi di Milano, being a framework for language composition and
modularization, presents a promising solution. By extending its capabilities to support a universal
LSP and DAP, reusable, language-agnostic feature modules can be created. This approach aims to
reduce development effort and complexity compared to traditional top-down methods. Empirical ev-
idence suggests that a modular framework could significantly improve maintainability, extensibility,
and productivity in language support tool development.


The primary aim of this project is to develop a Universal Language Server Protocol1 (LSP)
and Debugger Adapter Protocol2 (DAP) for modular language workbenches (LWs). This en-
deavor seeks to address significant gaps and challenges developing LSPs and DAPs in the current
landscape of language workbenches, particularly in the areas of modularization, composition, and
interoperability. Current language workbenches such as Melange [12], MontiCore [22], Spoofax [19],
and MPS [43, 44] have made significant strides in supporting modularization, composition, and IDE
integration. The table below provides a comparison of various language workbenches in terms of
their support for modularization, precompiled feature support, native IDE generation, LSP genera-
support tion, and and LSP ?my modularization. contribution, The
 which can symbol be extended indicates to full all support, LWs that # support partial at support, least component
 #
 G limited
modularization (identified by ★). The second column indicates the level of support for modular-
ization of artifacts and language features (more detail in Project Description section). The third
column indicates the level of support for precompiled features, the importance of this feature lies in
the fact that an artifact can be used by several features being compiled once, and that one feature
can be used among several projects without the recompilation step. The fourth column indicates the
level of support for native IDE generation, this is because many LWs are supported by the existence
of some IDE and thus allow IDE generation for languages developed for IDEs that host them. The
generation and modularizazion of LSP and DAP is trivial shown by the fifth and sixth columns, re-
spectively. However, their approaches are often fragmented and lack a standardized method for LSP
and DAP generation and modularization, as shown in table. Neverlang [39, 41], developed at the
ADAPT-Lab3 of the Università degli Studi di Milano, being a comprehensive framework for language
composition and modularization that supports the development of language product lines [24, 8]
(LPLs), is a prime candidate for the implementation of the proposed LSP and DAP. The project
will leverage the existing capabilities of Neverlang to develop a universal LSP and DAP that can be
used across different programming languages and IDEs. This will enable developers to create exter-
nal domain-specific languages [15] (DSLs) and general-purpose languages (GPLs) more effectively
and efficiently, enhancing the overall development experience and productivity.
The project aims to achieve the following objectives:
Aim 1: Improve IDE and LSP Generation
Integrated Development Environment generation and support for the Language Server Protocol are
essential for the practical use of domain-specific languages (DSLs). While some language work-
benches like Xtext [6] support LSP generation [2], many do not, limiting their usability across
different editors and IDEs.
Relevance: By establishing a universal protocol for LSP and DAP, this project aims to bridge the
gap, enabling language workbenches to generate IDE support and LSPs more seamlessly. This will
ensure that languages developed using these workbenches can be used in any IDE that supports
these protocols, enhancing their accessibility and utility.
Aim 2: Facilitate LSP and DAP Modularization LSP and DAP modularization are not widely supported by current language workbenches [7]. This
feature is crucial for allowing different language components to communicate and function cohesively
within an IDE.
Relevance: Implementing support for LSP and DAP modularization will allow for better integration
and interaction of various language features, thereby improving the overall development experience
and capability of language workbenches. This aligns with the needs for more sophisticated and
integrated language development tools as highlighted in the contemporary research and development
literature.
Aim 3: Reduce to L × 1 the number of combinations to support L languages
Before the advent of LSP and DAP, developers had to implement language support for each editor
separately, having the number of combinations to support L languages in L × E, where E is the
number of editors. Currently, the number of combinations to support L languages is L + E [37], as
the Microsoft LSP and DAP are editor-agnostic, as shown in Figure 1. This project aims to reduce
the number of combinations to L × 1, by developing a universal LSP and DAP that can be used
across different programming languages and IDEs.
Relevance: Reducing the number of combinations required to support multiple languages will
simplify the development process and make it more efficient. This will enable developers to create
language support more quickly and effectively, enhancing the overall productivity and usability of
language workbenches.
Aim 4: Leverage Neverlang for LSP and DAP in LPL Development
Neverlang’s capabilities for language composition and modularization make it an ideal platform for
developing a universal LSP and DAP that caters to a variety of language needs. By leveraging Nev-
erlang’s LPL development features [14], the project will establish a reusable core for LSP and DAP
functionalities, allowing for the creation of product line variations tailored to specific programming
language requirements. This will significantly reduce development time and effort for creating LSPs
and DAPs for new languages within the product line.
Relevance: Developing a core reusable base for LSP and DAP functionalities through Neverlang’s
LPL features will streamline the creation of new language support. This fosters a more efficient
and scalable approach to LSP and DAP development, aligning perfectly with the core principles of
software product lines.
Software languages, crucial not only in software engineering but also in various other fields [32,
10], require effective editing support for optimal use. This applies to both general-purpose languages
(GPLs) and domain-specific languages (DSLs). To aid in this accomplishment, modern Integrated
Development Environments (IDEs) and source-code editors (SCEs) provide a wide range of editing
support (e.g., syntax and semantic highlighting, intelligent code completion, debugging, and show
documentation on hovering over a primitive), but the development of such support is a complex
and time-consuming task [36]. The reduction of efforts in implementing this support has paved
the way for an advantageous strategy for programming language developers and maintainers, as
well as those developing integration tools, when an IDE would have provided the implementation
for their language and vice-versa. Then, given L languages and E editors, the number of possible
combinations is L × E for both LSP and DAP implementations, which is a large number. It means
that the development of a new language or editor would require a large amount of effort to provide
support for all possible combinations, with a significant amount of duplicated work and the risk of
introducing inconsistencies [34].
In contemporary times, advancements in techniques [35] such as the architecture of language
infrastructures [28, 42], Language Workbenches (LWBs) [13] and the implementation of specific
patterns [3, 29, 31] have been made to address this issue.
In this context, Microsoft in 2016 proposed the Language Server Protocol and the Debugger Adapter
Protocol for Visual Studio Code as a promising solution to this problem, reducing from L × E to
L + E the number of combinations to be implemented, as it decouples the implementation of the
language support from the editor (see Figure 2). Detailing, the LSP and DAP are protocols that
describes a common Application Programming Interface (API) that the language server (LS)
should implement, with the benefit of having only one implementation of the LS and multiple
clients (IDEs and SCEs) that can consume it, essentially establishing a client-server relationship
through a communication channel (e.g., pipes or sockets). However, the implementation of an LS
and its integration with an IDE/SCEs is still a complex task, as it requires the knowledge of the
LSP specification and the implementation of the language support. The implementation [16] of
an LS is done entirely manually and it is a top-down activity, where most of the time is spent on
the design and implementation data structures and algorithms. Recently, researchers have started
talking about the Software Product Lines (SPLs) [5, 14] to move towards a more modular world,
where the implementation of a software system can be done in a compositional way, by composing the
features of the SPL. When a SPL is applied to the implementation of a programming language, each
product corresponds to a language variant [24] taking the name of Language Product Lines (LPLs)
[24]. LPLs have been successfully used in both GPLs [9, 23, 24] and DSLs [17, 27, 40, 45, 46].
What I want to prove with this project is that the implementation of an LS could be a bottom-up
activity, where each LSP or DAP functionality can be see as a separate feature module [4, 18] splitted
across the language artifacts, where each artifacts can be part of one or more language features (see
Figure 3). These units can be composed to provide a modular implementation of the LS. This
approach is supported by the fact that the LSP and DAP are language-agnostic protocol [30, 36]
(see Fig. 1), which means that it does not impose any restrictions on the implementation of the
LS, as long as it respects the specification of the protocol. In feature-oriented programming (FOP)
[1, 11, 33], a feature module is a unit of composition that encapsulates a specific functionality, and
it is a first-class entity that can be composed with other feature modules to form a software system;
similar to an aspect module that encapsulates a crosscutting concern in aspect-oriented programming
(AOP) [20, 21, 26]. So, proponing a new modular approach to the implementation of an LS, based
also on FOP, I want to extend Neverlang Language Workbench [39, 41] in order to give support
to the implementation of the LS for any artifact of the language, and I will also implement the
Neverlang LSP [25] and DAP to support the composition of the LS feature modules. In this way,
the implementation of the LS is a bottom-up activity, where each artifact has attached a part of LSP
and DAP feature module that implements the LS functionality for that action, and these units can
be composed to provide a modular implementation. Feature modules will be written using a DSL,
developed in the context of the Neverlang framework, that is specific for the implementation of the
LS, and it is independent from the language for which the LS is being implemented. Furthermore,
with this approach, I want to prove that it is possible to reduce the number of combinations from
L + E to L × 1 by generating client implementations; this will be done by implementing a client
generator that will take as input the LS feature module and will produce the client implementation.
This will be supported by the implementation of a client language that will allow the developer to
specify which client to generate. The client generator will be able to generate clients for different
IDEs and SCEs, such as Visual Studio Code, Vim/Nvim and IntelliJ IDEA.
Methodology
The first step involves defining feature modules, which are essential components that encap-
sulate different functionalities of Language Server Protocol (LSP) and Debug Adapter Protocol
(DAP). These functionalities include syntax highlighting, code completion, debugging, and docu-
mentation support. Each feature module is identified and defined based on its specific role within
the LSP and DAP ecosystem. Following the identification of feature modules, the next phase is
developing a modular framework within the Neverlang Language Workbench to support the im-
plementation of these feature modules. This framework will provide the necessary infrastructure for
creating, composing, and managing the feature modules effectively. This phase will involve designing
and implementing the necessary data structures and innovative algorithms to support the modular
framework. An imporant step is developing domain-specific languages (DSLs) within Neverlang.
These DSLs are tailored to facilitate the development and composition of the feature modules,
providing a structured and efficient way to create and manage them. Once the feature modules
are defined and the DSLs are developed, the next step is to implement a system within Neverlang
that allows for the composition of these feature modules. This system enables the integration of
various feature modules into a complete and functional Language Server (LSP/DAP variant in
Fig. 3). With the modular framework in place, the next phase involves developing Language Servers
for multiple programming languages. This step demonstrates the reuse and compositional capa-
bilities of the feature modules. By leveraging the modular design, Language Servers for different
languages can be developed more efficiently and with greater consistency. To ensure the effectiveness
of these Language Servers, their performance and integration within different Integrated Develop-
ment Environments (IDEs) and Source Code Editors (SCEs) will be evaluated. This evaluation will
focus on how well the Language Servers perform in real-world development environments and how
seamlessly they integrate with existing tools. The final phase of the methodology involves a compre-
hensive comparison and analysis. This includes evaluating the effort and complexity involved in
the modular approach compared to traditional top-down methods. By analyzing the development
process, the benefits and challenges of using a modular framework can be assessed. Additionally,
the maintainability and extensibility of the modular approach will be scrutinized. This involves
introducing changes and enhancements to the Language Servers and observing how easily these
modifications can be implemented. The goal is to determine whether the modular approach offers
superior maintainability and extensibility compared to traditional methods.
Expected Contributions
• A Modular Framework for Language Server Development: A comprehensive frame-
work within the Neverlang Language Workbench that supports the modular development of
Language Servers.
• Reduction in Development Effort: Empirical evidence demonstrating a reduction in the
development effort and complexity associated with implementng Language Servers.
• Reusable and Language-Agnostic Modules: A library of reusable, language-agnostic
feature modules for common LSP and DAP functionalities.
• Case Studies and Practical Applications: Detailed case studies showcasing the practical
applications of the modular approach across different programming languages and development
environments.
• Evaluation and Comparison: A comprehensive evaluation and comparison of the modular
approach with traditional top-down methods, highlighting the benefits and challenges of each
approach.
Timeline
In figure 4 is shown the proposed timeline for the research project. The project is divided into
seven main phases:
• Literature Review
• Design and development of feature modules
• DSLs implementation for LSP and DAP
• Composing feature modules within Neverlang
• Universal Clients Generation
• Testing modularization with 3 LSs
• Evaluation comparison and analysis
The literature review phase will be carried out in the first six months. I will start by expanding
my knowledge LSP and DAP in general, and then I will perform a deeper study of all the most
important approaches currently available in literature to elaborate on their pros and cons and lay a
groundwork for my research work. Great attention would be given to the study of bottom-up and
top-down approaches, in order to find their shared aspects. This process will lead to the drafting of
a survey on feature-oriented programmin and software product lines. During the next eight months,
I will design and develop the feature modules for the LS, and I will extend the Neverlang
framework to support the implementation of the LS feature modules. This will be supported by the
implementation of generic data structures, such as Indexed Trees, Dependency Graphs, and Symbol
Tables, that will be populated by any given language artifact not known a priori. An additional
compilation step will be added to the Neverlang framework to generate the feature modules from
the language artifacts. In the following eight months, I will implement the DLSs for the LSP
and DAP, and I will extend the Neverlang framework to support the composition of the LS feature
modules through the DLSs. This will be supported by the implementation of a multi-dimensional
variability model [38]. One of the biggest challenges, in the next six months, will be to compose
the feature modules. This will be done by implementing a composition algorithm that will take
as input the splitted feature modules and the language artifacts and will produce the LS feature
module. The following six months will be dedicated to the universal clients generation. This
will be done by implementing a client generator that will take as input the LS feature module and
will produce the client implementation. This will be supported by the implementation of a client
language that will allow the developer to specify which client to generate. The client generator will
be able to generate clients for different IDEs and SCEs, such as Visual Studio Code, Vim/Nvim
and IntelliJ IDEA. In the last six months, I will test the modularization with three LSs, evaluating
the feasibility of the approach. This will be done by implementing the LS for three different
languages and by generating the client implementations. The evaluation will focus on the effort
and complexity involved in the development of the LS, the maintainability and extensibility of
the LS, and the integration of the LS with the existing tools. The evaluation will also include a
comparison with the traditional approach to LS development, to assess the benefits and challenges
of using the modular framework.
Conclusion
The proposed modular approach to implementing Language Servers via feature-oriented program-
ming within the Neverlang Language Workbench represents a significant advancement in reducing
the complexity and effort associated with developing Language Servers. By decomposing the LS
functionalities into reusable and composable feature modules, this approach promises to enhance
maintainability, extensibility, and overall efficiency in the development of language support tools.
Considering the potential impact of this research, I am confident that the proposed project will
yield valuable contributions to the field of programming language development and integration.
By providing a modular framework for the implementation of Language Servers, this research has
the potential to revolutionize the way language support tools are developed and maintained. The
reduction in development effort, the increased reusability of feature modules, and the improved main-
tainability and extensibility of Language Servers are just a few of the benefits that this research aims
to deliver. With the proposed timeline and methodology, I am confident that this research project
will be completed successfully and will make a significant contribution to the field of programming
languages.
